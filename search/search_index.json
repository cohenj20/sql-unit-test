{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>In Development</p> <p>This site is currently under development. Please do not use it as a reference for finalized procedures, guides, or standards. </p>"},{"location":"#welcome","title":"Welcome","text":"<p>This is the documentation site for <code>sql-unit-test</code>, a CLI tool that permits growing data teams to adopt test driven development best practices.</p> <p></p>"},{"location":"#back-story","title":"Back Story","text":"<p>The idea that drove the development of this tool is the notion that we (data people) should be writing unit tests for each object in our datawarehouse. That way we are able to systematically confirm that our assets are behaving in a way that we expect they should. Furthermore, previously written unit tests should be retained in some centralized place (ideally a source controlled place) so that we can check if new developments break requirements from past developments.</p> <p>There are tools on the market that accomplish this goal very effectively (read 'dbt'), however, for many organizations, the road to implementing dbt is a long one. In the meantime, it didn't seem like an option to simply opt out of what is (luckily) becoming a fundamental best practice in the data world. </p> <p>While it may not be as convenient and quick as declaring tests in dbt, <code>sql-unit-test</code> is certainly is a big step in the right direction. </p>"},{"location":"docs/contributing/","title":"Contributing","text":""},{"location":"docs/contributing/#contributers-welcome","title":"Contributers Welcome!","text":"<p>Contribution from the any and all is welcomed and appreciated! Check out the issues on github. If you have an idea for an enhancement, or notice something not working properly, please do open a new issue and open a pull request if you want to lend a hand!</p>"},{"location":"docs/contributing/#environment-setup","title":"Environment setup","text":"<p>Here's how to set up your development environment:</p> <ol> <li>Clone the repository in your development environment.</li> <li>Install poetry if it is not already installed on your system.</li> <li>Run the <code>poetry install</code> command to install the project dependencies. </li> <li>At the root of the repo run <code>poetry run python path/to/commands.py init</code>. This will create a file called <code>sql-unit-test.yaml</code> at the root, among other things. Change the <code>app_env</code> value to be 'dev'.</li> <li>To adjust the log level, modify the <code>log_level</code> value in <code>sql-unit-test.yaml</code>. (Options are <code>CRITICAL</code>/<code>WARN</code>/<code>ERROR</code>/<code>INFO</code>/<code>DEBUG</code>; default is <code>WARN</code>)</li> <li>Get developing!</li> <li>To test run the package use poetry: <code>poetry run python path/to/commands.py run</code> in /sample/playlists or in a unit test directory you create.</li> </ol>"},{"location":"docs/contributing/#testing","title":"Testing","text":"<p>It is requested that contributers write new unit tests for any new or modified functionality in the codebase. Please put these in the <code>/tests</code> folder. </p> <p>Feel free to run your tests locally, but the tests will also be executed by github upon the opening of your pull request.</p>"},{"location":"docs/installation/","title":"Installation","text":""},{"location":"docs/installation/#installion","title":"Installion","text":"<p>Super simple! To install sql-unit-test, it is recommended to use pip:</p> <pre><code>pip install sql-unit-test\n</code></pre>"},{"location":"docs/usage/","title":"Usage","text":""},{"location":"docs/usage/#overview","title":"Overview","text":""},{"location":"docs/usage/#the-sql-unit-test-init-command","title":"The <code>sql-unit-test init</code> command","text":"<p>The idea is to create one place for all of your sql unit tests. Follow the steps below to initialize a sql unit test project folder:</p> <ol> <li> <p>If you don't already have a folder to hold your unit tests, create one and cd into it.</p> <pre><code>mkdir &lt;your folder name&gt;\ncd &lt;your folder name&gt;\n</code></pre> </li> <li> <p>Then run the following command:     <pre><code>sql-unit-test init\n</code></pre>     Once the initialization is complete, you should see the following output:     <pre><code>=======================================================================================================================\n                                                SQL Unit Test\n=======================================================================================================================\n\n\n                            Project successfully initialized in &lt;your folder name&gt;!\n</code></pre></p> </li> <li>You should see three new objects in your directory: a <code>.gitignore</code> file, a <code>.sql-unit-test</code> folder, and a <code>sql-unit-test.yaml</code> configuration file.</li> </ol>"},{"location":"docs/usage/#configuration","title":"Configuration","text":"<p>The following configuration values can be set by a user. (* = required)</p> <ul> <li><code>app_env</code>: This doesn't need to be touched unless you are a developer contributing to <code>sql-unit-test</code>.</li> <li><code>uri*</code>: This is a valid sqlalchemy uri string that points to the database which holds the objects you want to run unit tests against. </li> <li><code>target_dir</code>: This is the directory in which to execute the <code>sql-unit-test run</code> command. Default is the current working directory.</li> <li><code>log_level</code>: This value overrides the log level used. The default value is <code>WARN</code>.</li> </ul> <p>The most convenient way to set these values is in the <code>sql-unit-test.yaml</code> at the root of the project. They can also be set at runtime by passing in the value as an option to the <code>sql-unit-test run</code> command. (ex. <code>sql-unit-test run --uri 'sqlite:///sample//test_database.db'</code>)</p> <p>Below is the order of operations that <code>sql-unit-test run</code> takes to find the proper config:</p> <ol> <li>Checks for config values passed to the command as options.</li> <li>Checks for <code>sql-unit-test.yaml</code> in current working directory.</li> <li>Walks up the folder hierarchy until it finds <code>sql-unit-test.yaml</code> in the project root or times out after searching for 1 second.</li> <li>Uses defaults for non-required config values.</li> </ol> <p>Therefore, the <code>uri</code> config value must either be passed as an option at runtime or be present in the <code>sql-unit-test.yaml</code>, as it is required and has no default value.</p>"},{"location":"docs/usage/#unit-test-repo-cold-setup","title":"Unit Test Repo Cold setup","text":"<p>This tool is made to be used in a repository with a particular structure. </p> <p>The recommended repo structure is one that models the interior structure of your data warehouse. This helps greatly with organizing the unit tests. Here's an example, where our data warehouse contains 3 databases. </p> <pre><code>.\n\u251c\u2500\u2500\u2500prod # db level\n\u2502   \u251c\u2500\u2500\u2500sales # schema level\n\u2502   \u2502   \u251c\u2500\u2500\u2500factOrders # object level\n\u2502   \u2502   \u2514\u2500\u2500\u2500...\n\u2502   \u2514\u2500\u2500\u2500...\n\u2502       \u2514\u2500\u2500\u2500...\n\u251c\u2500\u2500\u2500raw # db level\n\u2502   \u251c\u2500\u2500\u2500crm # schema level\n\u2502   \u2502   \u251c\u2500\u2500\u2500customers # object level\n\u2502   \u2502   \u2514\u2500\u2500\u2500...\n\u2502   \u2514\u2500\u2500\u2500...\n\u2502       \u2514\u2500\u2500\u2500...\n\u2514\u2500\u2500\u2500stage # db level\n    \u251c\u2500\u2500\u2500crm # schema level\n    \u2502   \u251c\u2500\u2500\u2500stg_customers # object level\n    \u2502   \u2514\u2500\u2500\u2500...\n    \u2514\u2500\u2500\u2500...\n        \u2514\u2500\u2500\u2500...\n</code></pre> <p>While this is the recommended unit test repo structure, the level at the root of the repository does not necessarily have to be database. It is valid to split up unit tests in any number of ways. The only hard fast requirement to be able to run <code>sql-unit-test</code> is that the test directory contains only valid sql unit test files. </p>"},{"location":"docs/usage/#writing-sql-unit-tests","title":"Writing sql unit tests","text":"<p>TODO</p>"},{"location":"docs/usage/#sql-unit-test-run","title":"<code>sql-unit-test run</code>","text":"<p>Running <code>sql-unit-test</code> is simple. </p> <p>The most convenient way to run it is by setting up <code>sql-unit-test.yaml</code> the file with your important config values, and then simply cd'ing into the desired target folder within the unit test repo and running <code>sql-unit-test run</code> in the command line. </p> <p>Let's take a look at the usage output straight from the command line:</p> <pre><code>PS J:\\Justin\\internal_tools\\sql-unit-test&gt; sql-unit-test --help\nUsage: sql-unit-test [OPTIONS]\n\nOptions:\n  --uri TEXT         A sqlalchemy URI that will override the URI provided in\n                     .env.\n  --target_dir TEXT  The target directory in which run sql-unit-test. Default\n                     is the current directory from which the sql-unit-test\n                     command is run.\n  --filepath TEXT    A path to a single sql unit test file.\n  --help             Show this message and exit.\n</code></pre> <p>Passing in any of these options will also override config values that are set in the <code>sql-unit-test.yaml</code>.</p>"}]}